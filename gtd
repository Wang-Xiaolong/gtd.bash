#!/usr/bin/env bash
# env here is to use the 1st bash in $PATH -- it's a BKM

usage() {  #heredoc
	cat<<-EOF
gtd = Getting Things Done
Collect and manage your ideas, todos, logs and files.
Usage:
  . ${BASH_SOURCE[0]} init
  gtd [-h|--help|-?]
  gtd <command> [<args>]

The most commonly used gtd commands are:
  init		Make the gtd command available.
  add		Add a new file to the library.
  remove	Remove files from the library.
  list		List files in the library.
  view		View a file in the library.
  edit		Edit a file in the library.
  set		Set the attributes of a file in the library.
	EOF
}

debug() { [ $debug == true ] && >&2 echo "$@"; }
vecho() { [ $verbose == true ] && echo "$@"; }
# only "$@" can trans args properly, $@/$*/"$*" can't.
str_trim() { echo "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'; }

#=== THE FILE SYSTEM ===========================================================
# Every object in the library is a file.
# Files are stored in directories named by their create years, e.g.
#   2016/ 2017/ 2018/ ...
# The name of a file contains its attributes, e.g.
#   20170829103244.id=1001.alias=coding_style.tag=script,todo,closed.txt
# Attributes are separated by a dot '.',
# The first attribute is the create time, in the format of yyyymmddHHMMSS, e.g.
#   20170829103244
# The last attribute is the type or ext of the file, could be anything, e.g.
#   txt, log, doc, ppt, jpg ... the default created type is mt, the marktree.
# The attributes in the middle need to be formatted as
#   attribute=value or attribute=value1,value2,... e.g.
#   id=1001 or category=home,office,car

GTD_ID_BASE=1000
fs_get_max_id() { # no arg; +1 to create new id number
	local res=`ls "$GTD_ROOT" -R -1 | grep ".id=" | cut -d '.' -f 2 \
	  | cut -d '=' -f 2 | sort -n | tail -n1`
	[ -z "$res" ] && echo "$GTD_ID_BASE" || echo "$res"
}

fs_get_new_fn() { # fn: file name;
	local date=`date +%Y%m%d%H%M%S`
	local id=$(( `fs_get_max_id` + 1 ))
	echo "$date.id=$id.mt"
}

fs_fn2fp() { # fp: file path; $1=fn
	local year=${1:0:4}
	echo "$GTD_ROOT/$year/$1"
}

fs_get_new_fp() {
	local fn=`fs_get_new_fn`
	fs_fn2fp "$fn"
}

fs_id2fn() { # $1=id
	ls -R -r -1 "$GTD_ROOT" | grep ".id=$1."
}

fs_id2fp() { # $1=id
	local fn=`fs_id2fn "$1"`
	[ -z "$fn" ] && return
	fs_fn2fp "$fn"
}

fs_parse_fn() { # $1=fn; fn->fields
	IFS='.' read -ra PARTS <<< "$1"
	for str in "${PARTS[@]}"; do
		echo $str
	done
	echo "${PARTS[0]}" # time
	echo "${PARTS[-1]}" # type
}

fs_print_fi() { # fi: file info; $1=fn $2=format=0|1|2|...|v
  # 0 -- file info only, 1 line
  # 1 -- file info and 1 content line, 1 or 2 lines
  # 2+ -- file info and 2+ content line
  # v -- file info and view all content
	IFS='.' read -ra PARTS <<< "$1"
	local ct="${PARTS[0]}" # create time
	local cts="${ct:0:4}-${ct:4:2}-${ct:6:2} ${ct:8:2}:${ct:10:2}" # ct str
	local id=`echo "${PARTS[1]}" | cut -d "=" -f 2`
	local ext="${PARTS[-1]}"
	local fp=`fs_fn2fp $1` # file path
	if [ "$2" == "1n" ]; then # put 1n here is improve 1n perf
		[ "$ext" == "mt" ] && \
		  n1=`head -n1 "$fp" | sed 's/<mt.*>//g'` \
		  || n1="[$ext]"
		echo "[$cts] $id: $n1"
		return
	fi
#	for field in "${PARTS[@]}"; do # get all other fields
#		echo $str
#	done
	case "$2" in
	2n) echo ;;
	8n) echo ;;
	full) echo ;;
	*) echo "Wrong fs_print_fi arg2: $2"; exit 1;;
	esac
}
#==- CONFIG: .gtdrc ============================================================
usage_config() {
	cat<<-EOF
You can write a .gtdrc config file in the directory of this script to store
you configurations.
The format is like a ini file:
# comment1
key1 = value1
[section]
  key2 = value2

== Command Alias Configuration ==
"gtd" is not quite smooth when typing on keyboard, maybe "gge" is faster.
You can write the command alias in .gtdrc, [alias] section.
And the command alias will be set after you initialized gtd using init command.
Here is an example:
[alias]
  gga = gtd add
  ggl = gtd list
  gge = gtd edit
	EOF
}

get_config_section() { # $1=section, if no, get global lines
	debug "get_config_section($1)"
	[ ! -f "$GTD_ROOT/.gtdrc" ] && debug "no .gtdrc" && return
	local section=""
	while read -r line || [[ -n "$line" ]]; do
		if [[ "$line" == \#* ]]; then # comment
			debug "comment line: $line"
			continue
		elif [[ -z "${line// }" ]]; then # empty
			debug "empty line: $line"
			continue
		elif [[ "$line" == \[*\] ]]; then # section
			debug "section line: $line"
			section=`echo $line | tr -d []`
		else
			debug "ordinary line: $line"
			if [[ $# -eq 0 ]]; then # no section specified
				[ -z "$section" ] && echo "$line"
			elif [ "$section" == "$1" ]; then
				echo "$line"
			fi
		fi
	done < "$GTD_ROOT/.gtdrc"
}

print_config_line() { # $1=line, $2=format, %k=key, %v=value
	debug "print_config_line($1, $2)"
	IFS='=' read key value <<< "$1" # split line to key & value by =
	key=`str_trim "$key"` # trim white spaces
	value=`str_trim "$value"`
	debug "key: $key, value: $value"
	key_replaced=${2//%k/$key} # %k->key
	value_replaced=${key_replaced//%v/$value} # %v->value
	debug "print_config_line() return: $value_replaced"
	echo "$value_replaced"
}

get_config() { # $1=key, $2=section, optional
	debug "get_config($@)"
	[ ! -f "$GTD_ROOT/.gtdrc" ] && debug "no .gtdrc" && return
	local line=`get_config_section $2 \
	  | grep -e "^[[:space:]]*$1[[:space:]]*="`
	[ -z "$line" ] && return
	print_config_line "$line" "%v"
}
#=== INIT ======================================================================
usage_init() {
	cat<<-EOF
Usage: . ${BASH_SOURCE[0]} init
This command should be run in source mode before any other gtd command.
It will make gtd a command by adding the path of the directory containing
  this script to system PATH.
The directory will also be used as the working directory of the gtd commands,
  all files will be stored here.
Command alias will also be registerred if they are written in the .gtdrc
  config file in the same directory. 'gtd config -h' to get the detail.
	EOF
}

gtd_init() {
	if [[ "$0" != *"bash" ]]; then # $0 is path of bash indicate
	  # it runs in current shell (or source mode, ". gtd"),
	  # init should run in current shell to keep the vars.
		echo "init should be run in source mode: '. $0 init'"
		usage_init
		return
	fi
	# bkm to get the dir path of the script file
	code_dir="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
	echo "The working directory: $code_dir"
	export GTD_ROOT="$code_dir" # files are with the script

	# +PATH to make gtd a command, no need for the 2nd init
	[[ ! "$PATH" =~ "$code_dir" ]] && export PATH="$PATH:$code_dir"

	# alias command from .gtdrc [alias] alias=cmd
	# alias -p to check the result
	alias_lines=`get_config_section alias`
	debug "alias_lines: $alias_lines"
	while read -r line; do
		cmd=`print_config_line "$line" "alias %k='%v'"`
		echo "$cmd" && eval $cmd # eval, bkm to exe a string
	done <<< "$alias_lines"
}
#=== ADD =======================================================================
usage_add() {
	cat<<-EOF
Usage: gtd add [OPTION]...

  -f, --file=PATH
  -m, --message=MESSAGE
  -e, --editor=EDITOR
      --template=TEMPLATE
  -t, --time=TIME
	EOF
}

gtd_add() {
	TEMP=`getopt -o ef:m:t: \
	  --long editor:,file:,message:,template:,time: \
	  -n 'gtd.add' -- "$@"`
	[ $? != 0 ] && echo "Failed parsing the arguments." && return
	eval set -- "$TEMP"
	local path=""; local message=""; local template=""
	local time=""; local editor=""
	while : ; do
		case "$1" in
		-e|--editor) editor="$2"; shift 2;;
		-f|--file) path="$2"; shift 2;;
		-m|--message) message="$2"; shift 2;;
		--template) template="$2"; shift 2;;
		-t|--time) time="$2"; shift 2;;
		--) shift; break;;
		*) echo "Unknown option: $1"; return;;
		esac
	done

	path=`fs_get_new_fp`
	if [ ! -z "$message" ]; then
		install -D /dev/null "$path"
		echo "$message" > "$path"
		echo "`basename $path` created."
		return
	fi

	if [ $verbose == true ]; then # verbose -- open with an editor
		select_editor
		[ -z "$editor" ] && return
		install -D /dev/null "$path"
		echo "Edit $path ..."
		$editor "$path"
		return
	fi

	echo "Any stuff, please (ctrl-d to end, ctrl-c to cancel):"
	[ $in_shell == true ] && trap "echo; return" INT
	local input=`cat` # save keyin until eof
	if [ -z `echo $input | tr -d '[:space:]'` ]; then # empty check
		echo "Nothing!"
		return
	fi
	install -D /dev/null "$path"
	echo "$input" > "$path"
	echo "`basename $path` created."
}
#=== LIST ======================================================================
usage_list() {
	cat<<-EOF
Usage:
  gtd list [OPTION]...
  gtd list [OPTION]...

  -o, --option=VALUE  Meaning
	EOF
}

gtd_list() {
	TEMP=`getopt -o ab: --long apple,banana: \
	  -n 'gtd.list' -- "$@"`
	[ $? != 0 ] && echo "Failed parsing the arguments." && return
	eval set -- "$TEMP"
	apple=false; banana=""
	while : ; do
		case "$1" in
		-a|--apple) apple=true; shift;;
		-b|--banana) banana="$2"; shift 2;;
		--) shift; break;;
		*) echo "Unknown option: $1"; return;;
		esac
	done

	for fn in `ls -R -r -1 "$GTD_ROOT" | grep ".id="`; do
		fs_print_fi "$fn" "1n"
	done
}
#=== Edit =====================================================================
usage_edit() {
	cat<<-EOF
Usage: gtd edit [OPTION]... <id or alias>
Edit a file with a specified editor.
The file is specified by its id or alias.
The editor can be specified with the following method (sorted by priority):
  1. Use option -e or --editor
  2. Use GTD_EDITOR variable
  3. Use editor variable in the .gtdrc file beside the gtd command script. 
  4. If none of the above provided, use vim or vi if your OS provided them.

Options:
  -e, --editor=EDITOR  Use the specified editor.
	EOF
}

#TODO: test the options choosing the editor
select_editor() { # need $editor in the caller and will manipulate
	if [ -z "$editor" ]; then
		if [ -z "$GTD_EDITOR" ]; then
			editor=`get_config editor`
			[ ! -z editor ] && \
			  vecho "Editor $editor specified from .gtdrc."
		else
			editor="$GTD_EDITOR"
			vecho "Editor $editor specified from GTD_EDITOR."
		fi
	fi
	if [ -z "$editor" ]; then
		if [ ! -z `command -v vim` ]; then
			editor=vim
		elif [ ! -z `command -v vi` ]; then
			editor=vi
		else
			echo "No editor specified, and no vim or vi."
			echo "Please specify an editor that can be used."
			usage_edit
			return
		fi
		echo "No editor specified, using $editor."
	else # editor specified, check it's existence
		if [ -z `command -v $editor` ]; then # not exist
			echo "Editor $editor not exist, please try another."
			return
		fi
	fi
}

gtd_edit() {
	TEMP=`getopt -o e: --long editor: \
	  -n 'gtd.edit' -- "$@"`
	[ $? != 0 ] && echo "Failed parsing the arguments." && return
	eval set -- "$TEMP"
	local editor=""
	while : ; do
		case "$1" in
		-e|--editor) editor="$2"
			vecho "Editor $editor specified from command line."
			shift 2;;
		--) shift; break;;
		*) echo "Unknown option: $1"; return;;
		esac
	done

	select_editor
	[ -z "$editor" ] && return

	if [ $# -eq 0 ]; then # no arg -- edit this script file
		fn="${BASH_SOURCE[0]}"
	else
		fn=`fs_id2fp $1`
		[ -z "$fn" ] && echo "ID $1 not found." && return
	fi
	echo "Edit $fn ..."
	$editor "$fn"
}

#=== TEST functions in place ===================================================
usage_test() {
	cat<<-EOF
Usage: gtd test [OPTION]...
Internal test of gtd functions.

Options:
  -o, --option=VALUE  Meaning
	EOF
}

gtd_test() {
	TEMP=`getopt -o t: --long task: -n 'gtd.test' -- "$@"`
	[ $? != 0 ] && echo "Failed parsing the arguments." && return
	eval set -- "$TEMP"
	local task=""
	while : ; do
		case "$1" in
		-t|--task) task="$2" shift 2;; #TODO:support multi task
		--) shift; break;;
		*) echo "Unknown option: $1"; return;;
		esac
	done

	fn=`fs_id2fn 1006`
	fs_parse_fn $fn
}
#=== SHELL =====================================================================
usage_shell() {  #heredoc
	cat<<-EOF
Shell-like environment, where you can run gtd commands without typing 'gtd'.
	EOF
}

in_shell=false
process_command() {
	[ $# -eq 0 ] && usage && return 0  #No arg, show usage

	case "$1" in  #$1 is command
	init) [ $help_me == true ] && usage_init || gtd_init;;
	config) [ $help_me == true ] && usage_config || vim "$GTD_ROOT/.gtdrc";;
	a|add) shift; [ $help_me == true ] && usage_add || gtd_add "$@";;
	l|ls|list) shift; [ $help_me == true ] && usage_list || gtd_list "$@";;
	e|edit) shift; [ $help_me == true ] && usage_edit || gtd_edit "$@";;
	shell) [ $in_shell == false ] && gtd_shell "$@"\
	  || echo "We are already in gtd shell.";;
  	exit) [ $in_shell == true ] && in_shell=false \
	  || echo "exit is a gtd shell command.";;
  	help) usage;;
	version) echo "0.02 2017-08-24 paulo.dx@gmail.com";;
	test) shift; [ $help_me == true ] && usage_test || gtd_test "$@";;
	*) echo "Incorrect command: $1"; usage;;
	esac
	return 0
}

gtd_shell() {
	[ $help_me == true ] && usage_shell && return

	in_shell=true
	while : ; do # infinite loop
		printf "gtd~ "
		read args
		eval set -- "$args"
		process_command "$@"
		[ $in_shell == false ] && break
	done
}
#=== MAIN ======================================================================
[ $# -eq 0 ] && usage && exit # bkm for no arg check

# process help & verbose & debug in 1 place
args=() # empty array
help_me=false; verbose=false; debug=false
for arg in "$@"; do
	case "$arg" in
	'-?'|-h|--help) help_me=true;; # ? is a wildcard if not br by ''
	-v|--verbose) verbose=true;;
	--debug) debug=true;;
	*) args+=("$arg");; # collect args other than help/verbose/debug
	esac
done

if [[ $help_me == false && "$1" != init ]]; then
  # help_me will always be processed (because showing help need nearly nothing)
  # init will always be processed
  # other commands need at least a working dir, and should run in child shell
	if [[ "$0" == *"bash" ]]; then # source mode: `. gtd` or `source gtd`
		echo "gtd command should not run in source mode."
		return # exit in source mode will exit the shell
	fi # common (non-source) mode below
	if [ -z "$GTD_ROOT" ]; then
		echo "No working directory specified."
		echo "Please run '. $0 init' first."
		usage_init
		exit 0
	fi
fi

[ -z $(command -v getopt) ] && echo "No getopt command." && exit 1
#TODO: give the user some hint to find the package containing the getopt cmd
process_command "${args[@]}"
#=== Template ==================================================================
usage_template() {
	cat<<-EOF
Usage: gtd template [OPTION]...
Description

Options:
  -o, --option=VALUE  Meaning
	EOF
}

gtd_template() {
	TEMP=`getopt -o ab: --long apple,banana: \
	  -n 'gtd.template' -- "$@"`
	[ $? != 0 ] && echo "Failed parsing the arguments." && return
	eval set -- "$TEMP"
	local apple=false; local banana=""
	while : ; do
		case "$1" in
		-a|--apple) apple=true; shift;;
		-b|--banana) banana="$2"; shift 2;;
		--) shift; break;;
		*) echo "Unknown option: $1"; return;;
		esac
	done
}
