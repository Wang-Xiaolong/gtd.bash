#!/usr/bin/env bash
# env here is to use the 1st bash in $PATH -- it's a BKM

usage() {  #heredoc
	cat<<-EOF
gtd = Getting Things Done
Collect and manage your ideas, todos, logs and files.
Usage:
  . ${BASH_SOURCE[0]} init
  gtd [-h|--help|-?]
  gtd <command> [<args>]

The most commonly used gtd commands are:
  init		Make the gtd command available.
  cd|chdir	Change the working directory.
  add		Add a new file to the library.
  md|mkdir	Add a new directory to the library.
  rm|remove	Remove files from the library.
  ls|list	List files in the library.
  view		View a file in the library.
  edit		Edit a file in the library.
  set		Set the attributes of a file in the library.
	EOF
}

#=== PUBLIC FUNCTIONS ==========================================================
debug() { [ $debug == true ] && >&2 echo "$@"; }
vecho() { [ $verbose == true ] && echo "$@"; }
# only "$@" can trans args properly, $@/$*/"$*" can't.
str_trim() { echo "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'; }

#=== FILE ======================================================================
# fn: file name
# fx: file attributs
#   ftime
#   fid
#   falias
#   fparent
#   fdep
#   fname
#   ftype
#   fattr[]
fn2fx() { # $1=fn; output: ftime, fid, ftype, fattr[]
	debug "fn2fx($1)"
	local PARTS, part
	IFS='.' read -ra PARTS <<< "$1"
	ftime=${PARTS[0]}; debug "ftime=$ftime"
	fid=${PARTS[1]:3}; debug "fid=$fid" # :3 to bypass id=
	ftype=${PARTS[-1]}; debug "ftype=$ftype"
	local attr_cnt=${#PARTS[@]}
	if [ $attr_cnt -le 3 ]; then
		debug "attr_cnt=$attr_cnt, no additional attributes."
		return
	fi
	attr_cnt=$attr_cnt-3
	for part in "${PARTS[@]:2:$attr_cnt}"; do # get all other fields
		fattr+=("$part")
	done
	debug "fattr: ${fattr[@]}"
}

fx2fn() { # input: ftime, fid, ftype, fattr[]; output: echo fn
	local fn="$ftime.id=$fid"
	for attr in "${fattr[@]}"; do
		fn="$fn.$attr"
	done
	fn="$fn.$ftype"
	echo "$fn"
}

#debug=true
#ftime=fid=ftype=""
#fattr=()
#fn2fx "11.id=12.pr=13.dep=14.name=hello.marktree"
#fx2fn
#exit

fx2fx() { # $1="set string"
	return
}

#=== THE FILE SYSTEM ===========================================================
# Every object in the library is a file.
# Files are stored in directories named by their create years, e.g.
#   2016/ 2017/ 2018/ ...
# The name of a file contains its attributes, e.g.
#   20170829103244.id=1001.alias=coding_style.tag=script,todo,closed.txt
# Attributes are separated by a dot '.',
# The first attribute is the create time, in the format of yyyymmddHHMMSS, e.g.
#   20170829103244
# The last attribute is the type or ext of the file, could be anything, e.g.
#   txt, log, doc, ppt, jpg ... the default created type is mt, the marktree.
# The attributes in the middle need to be formatted as
#   attribute=value or attribute=value1,value2,... e.g.
#   id=1001 or category=home,office,car

GTD_ID_BASE=1000
fs_get_max_id() { # no arg; +1 to create new id number
	local res=`ls "$GTD_ROOT" -R -1 | grep ".id=" | cut -d '.' -f 2 \
	  | cut -d '=' -f 2 | sort -n | tail -n1`
	[ -z "$res" ] && echo "$GTD_ID_BASE" || echo "$res"
}

fs_get_new_fn() { # fn: file name;
	local date=`date +%Y%m%d%H%M%S`
	local id=$(( `fs_get_max_id` + 1 ))
	echo "$date.id=$id.mt"
}

fs_fn2fp() { # fp: file path; $1=fn
	local year=${1:0:4}
	echo "$GTD_ROOT/$year/$1"
}

fs_get_new_fp() {
	local fn=`fs_get_new_fn`
	fs_fn2fp "$fn"
}

fs_id2fn() { # $1=id
	ls -R -r -1 "$GTD_ROOT" | grep ".id=$1."
}

fs_id2fp() { # $1=id
	local fn=`fs_id2fn "$1"`
	[ -z "$fn" ] && return
	fs_fn2fp "$fn"
}

fs_parse_fn() { # $1=fn; fn->fields
	IFS='.' read -ra PARTS <<< "$1"
	for str in "${PARTS[@]}"; do
		echo $str
	done
	echo "${PARTS[0]}" # time
	echo "${PARTS[-1]}" # type
}

fs_print_fi() { # fi: file info; $1=fn $2=format=0|1|2|...|v
  # 0 -- file info only, 1 line
  # 1 -- file info and 1 content line, 1 or 2 lines
  # 2+ -- file info and 2+ content line
  # v -- file info and view all content
	IFS='.' read -ra PARTS <<< "$1"
	local ct="${PARTS[0]}" # create time
	local cts="${ct:0:4}-${ct:4:2}-${ct:6:2} ${ct:8:2}:${ct:10:2}" # ct str
	local id=`echo "${PARTS[1]}" | cut -d "=" -f 2`
	local ext="${PARTS[-1]}"
	local fp=`fs_fn2fp $1` # file path
	if [ "$2" == "1n" ]; then # put 1n here is improve 1n perf
		[ "$ext" == "mt" ] && \
		  n1=`head -n1 "$fp" | sed 's/<mt.*>//g'` \
		  || n1="[$ext]"
		echo "[$cts] $id: $n1"
		return
	fi

	case "$2" in
	2n) echo ;;
	8n) echo ;;
	full) echo ;;
	*) echo "Wrong fs_print_fi arg2: $2"; exit 1;;
	esac
}
#==- CONFIG: .gtdrc ============================================================
usage_config() {
	cat<<-EOF
You can write a .gtdrc config file in the directory of this script to store
you configurations.
The format is like a ini file:
# comment1
key1 = value1
[section]
  key2 = value2

== Command Alias Configuration ==
"gtd" is not quite smooth when typing on keyboard, maybe "gge" is faster.
You can write the command alias in .gtdrc, [alias] section.
And the command alias will be set after you initialized gtd using init command.
Here is an example:
[alias]
  gga = gtd add
  ggl = gtd list
  gge = gtd edit
	EOF
}

get_config_section() { # $1=section, if no, get global lines
	debug "get_config_section($1)"
	[ ! -f "$GTD_ROOT/.gtdrc" ] && debug "no .gtdrc" && return
	local section=""
	while read -r line || [[ -n "$line" ]]; do
		if [[ "$line" == \#* ]]; then # comment
			debug "comment line: $line"
			continue
		elif [[ -z "${line// }" ]]; then # empty
			debug "empty line: $line"
			continue
		elif [[ "$line" == \[*\] ]]; then # section
			debug "section line: $line"
			section=`echo $line | tr -d []`
		else
			debug "ordinary line: $line"
			if [[ $# -eq 0 ]]; then # no section specified
				[ -z "$section" ] && echo "$line"
			elif [ "$section" == "$1" ]; then
				echo "$line"
			fi
		fi
	done < "$GTD_ROOT/.gtdrc"
}

print_config_line() { # $1=line, $2=format, %k=key, %v=value
	debug "print_config_line($1, $2)"
	IFS='=' read key value <<< "$1" # split line to key & value by =
	key=`str_trim "$key"` # trim white spaces
	value=`str_trim "$value"`
	debug "key: $key, value: $value"
	key_replaced=${2//%k/$key} # %k->key
	value_replaced=${key_replaced//%v/$value} # %v->value
	debug "print_config_line() return: $value_replaced"
	echo "$value_replaced"
}

get_config() { # $1=key, $2=section, optional
	debug "get_config($@)"
	[ ! -f "$GTD_ROOT/.gtdrc" ] && debug "no .gtdrc" && return
	local line=`get_config_section $2 \
	  | grep -e "^[[:space:]]*$1[[:space:]]*="`
	[ -z "$line" ] && return
	print_config_line "$line" "%v"
}
#=== INIT ======================================================================
usage_init() {
	cat<<-EOF
Usage: . ${BASH_SOURCE[0]} init
This command should be run in source mode before any other gtd command.
It will make gtd a command by adding the path of the directory containing
  this script to system PATH.
The directory will also be used as the working directory of the gtd commands,
  all files will be stored here.
Command alias will also be registerred if they are written in the .gtdrc
  config file in the same directory. 'gtd config -h' to get the detail.
	EOF
}

gtd_ps1() {
	local find_res=`find "$GTD_ROOT" -type d -wholename "$PWD"`
	if [ -n $find_res ]; then # PWD is within GTD_ROOT
		if [ "$GTD_ROOT" == "$PWD" ]; then
			echo "GTD"
		else	
			echo "GTD:${PWD#$GTD_ROOT/}" # relative path
		fi
	else # PWD is outside GTD_ROOT
		echo "$PWD"
	fi
}

gtd_init() {
	if [[ "$0" != *"bash" ]]; then # $0 is path of bash indicate
	  # it runs in current shell (or source mode, ". gtd"),
	  # init should run in current shell to keep the vars.
		echo "init should be run in source mode: '. $0 init'"
		usage_init
		return
	fi
	# bkm to get the dir path of the script file
	local code_dir="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
	echo "GTD working directory: $code_dir"
	export GTD_ROOT="$code_dir" # files are with the script

	# +PATH to make gtd a command, no need for the 2nd init
	[[ ! "$PATH" =~ "$code_dir" ]] && export PATH="$PATH:$code_dir"

	# alias command from .gtdrc [alias] alias=cmd
	# alias -p to check the result
	local alias_lines=`get_config_section alias`
	debug "alias_lines: $alias_lines"
	while read -r line; do
		local cmd=`print_config_line "$line" "alias %k='%v'"`
		echo "$cmd" && eval $cmd # eval, bkm to exe a string
	done <<< "$alias_lines"

	PS1="\e[0;32m\$(gtd ps1)\e[m \$ " # Green prompt

	local short_gtd_root=`get_config short_gtd_root`
	if [ -n "$short_gtd_root" ]; then
		export $short_gtd_root="$GTD_ROOT"
		echo "You can use \$$short_gtd_root"\
		  "to refer GTD working directory."
	fi
}
#=== Mkdir =====================================================================
usage_mkdir() {
	cat<<-EOF
Usage: gtd mkdir [OPTION]... DIRECTORY...
Create the DIRECTORY(ies), if they do not already exist.

Options:
  -a, --alias=ALIAS	create with alias as ALIAS,
                   	used when creating only 1 directory.
  -t, --type=TYPE	create with type as TYPE
  -n, --name=NAME       create with long name as NAME
  -v, --verbose		open an editor to edit the long name and detail.
  -s, --set=SETTING	create with special SETTING.
	EOF
}

get_max_dir_id() {
	debug "get_max_dir_id()"
	local max_id=0
	for fp in "$(find "$GTD_ROOT" -type f -name ".id=*")"; do
		[ -z "$fp" ] && continue
		local id="$(basename "$fp" | cut -d '.' -f 2 | cut -d '=' -f 2)"
		[ "$id" -gt "$max_id" ] && max_id=$id
	done
	echo $max_id
}

gen_new_dir_fn() {
	debug "gen_dir_fn(ali=$alias, typ=$type, nm=$name, set=${setting[@]})"
	local id=$(( `get_max_dir_id`+ 1 ))
	echo ".id=$id.marktree"
}

gtd_mkdir() {
	PARAMS="$(getopt -o a:t:n:s: --long alias:type:name:set: \
	  -n 'gtd.mkdir' -- "$@")"
	[ $? -ne 0 ] && echo "Failed parsing the arguments." && return
	eval set -- "$PARAMS"
	debug "gtd_mkdir($@)"
	local alias=""; local type=""; local name=""; local setting=()
	while : ; do
		case "$1" in
		-a|--alias) alias="$2"; shift 2;;
		-t|--type) type="$2"; shift 2;;
		-n|--name) name="$2"; shift 2;;
		-s|--set) setting+=("$2"); shift 2;;
		--) shift; break;;
		*) echo "Unknown option: $1"; return;;
		esac
	done

	[[ -n "$alias" && $# -gt 1 ]] \
	  && echo "Can't create multiple directories with the same alias." \
	  && return

	for dir in "$@"; do
		mkdir $dir
		if [ $? -ne 0 ]; then
			echo "Fail creating $dir."
			continue
		fi
		# dir created
		local fn=$(gen_new_dir_fn)
		touch "$dir/$fn"
	done
}
#=== ADD =======================================================================
usage_add() {
	cat<<-EOF
Usage: gtd add [OPTION]...

  -f, --file=PATH
  -m, --message=MESSAGE
  -e, --editor=EDITOR
      --template=TEMPLATE
  -t, --time=TIME
	EOF
}

gtd_add() {
	PARAMS=`getopt -o ef:m:t: \
	  --long editor:,file:,message:,template:,time: \
	  -n 'gtd.add' -- "$@"`
	[ $? -ne 0 ] && echo "Failed parsing the arguments." && return
	eval set -- "$PARAMS"
	debug "gtd_add($@)"
	local path=""; local message=""; local template=""
	local time=""; local editor=""
	while : ; do
		case "$1" in
		-e|--editor) editor="$2"; shift 2;;
		-f|--file) path="$2"; shift 2;;
		-m|--message) message="$2"; shift 2;;
		--template) template="$2"; shift 2;;
		-t|--time) time="$2"; shift 2;;
		--) shift; break;;
		*) echo "Unknown option: $1"; return;;
		esac
	done

	path=`fs_get_new_fp`
	if [ -n "$message" ]; then
		install -D /dev/null "$path"
		# 'install' can make the dirs on the way to the file
		echo "$message" > "$path"
		echo "`basename $path` created."
		return
	fi

	if [ $verbose == true ]; then # verbose -- open with an editor
		select_editor
		[ -z "$editor" ] && return
		install -D /dev/null "$path"
		echo "Edit $path ..."
		$editor "$path"
		return
	fi

	echo "Any stuff, please (ctrl-d to end, ctrl-c to cancel):"
	[ $in_shell == true ] && trap "echo; return" INT
	local input=`cat` # save keyin until eof
	if [ -z `echo $input | tr -d '[:space:]'` ]; then # empty check
		echo "Nothing!"
		return
	fi
	install -D /dev/null "$path"
	echo "$input" > "$path"
	echo "`basename $path` created."
}
#=== MOVE ======================================================================
usage_move() {
	cat<<-EOF
Usage: gtd move [OPTION]... SOURCE... DEST
   or: gtd move -t DESTIN SOURCE...
Move all files specified by SOURCE under the file of DEST.

Options:
  -t, --target=DEST  Move all SOURCE files under DEST
	EOF
}

fid2path() { # $1=id|alias; echo out path
	[[ $1 =~ ^[0-9]+$ ]] && find "$GTD_ROOT" -name "*.id=$1.*" \
	  || find "$GTD_ROOT" -name ".alias=$1."
}

fn2id() { # $1=fn; echo out id
	echo "$1" | cut -d '.' -f 2 | cut -d '=' -f 2
}

gtd_move_1file() { # $1=src id|alias; input: $dest_dir
	local src_path=`fid2path "$1"`
	[ -z "$src_path" ] && echo "No source $src found." && continue
	debug "src_path=$src_path"
	local src_dir=`dirname "$src_path"`
	local src_name=`basename "$src_path"`
	local src_id=`fn2id "$src_name"`
	[ ! -d "$dest_dir" ] && mkdir "$dest_dir"
	mv "$src_path" "$dest_dir"
}

gtd_move() {
	PARAMS=`getopt -o t: --long target: \
	  -n 'gtd.move' -- "$@"`
	[ $? != 0 ] && echo "Failed parsing the arguments." && return
	eval set -- "$PARAMS"
	debug "gtd_move($@)"
	local target=""
	local source=()
	while : ; do
		case "$1" in
		-t|--target) target="$2"; shift 2;;
		--) shift; break;; # after -- are non option args
		*) echo "Unknown option: $1"; return;;
		esac
	done
	if [ -z "$target" ]; then # no -t, source... target
		if [ $# -lt 2 ]; then
			echo "Source or target id/alias not specified."
			return
		fi
		target="${@:${#}}"
		source=( "${@:1:${#}-1}" )
	else # -t option->target, $@ all source
		if [ $# -eq 0 ]; then
			echo "Source id/alias not specified."
		fi
		source=( "$@" )
	fi
	debug "target=$target"
	debug "source=${source[@]}"
	# TODO: if target is under source, no move
	# TODO: if target==source, no move
	# TODO: if already in, no move
	# TODO: target is 0, move to root
	local target_path=`fid2path "$target"`
	[ -z "$target_path" ] && echo "No target $target found." && return
	debug "target_path=$target_path"
	local target_dir=`dirname "$target_path"`
	local target_name=`basename "$target_path"`
	local target_id=`fn2id $target_name`
	local dest_dir="$target_dir/$target_id"
	for src in "${source[@]}"; do
		gtd_move_1file "$src"
	done
}
#=== LIST ======================================================================
usage_list() {
	cat<<-EOF
Usage:
  gtd list [OPTION]...
  gtd list [OPTION]...

  -o, --option=VALUE  Meaning
	EOF
}

gtd_list() {
	PARAMS=`getopt -o ab: --long apple,banana: \
	  -n 'gtd.list' -- "$@"`
	[ $? != 0 ] && echo "Failed parsing the arguments." && return
	eval set -- "$PARAMS"
	debug "gtd_list($@)"
	apple=false; banana=""
	while : ; do
		case "$1" in
		-a|--apple) apple=true; shift;;
		-b|--banana) banana="$2"; shift 2;;
		--) shift; break;;
		*) echo "Unknown option: $1"; return;;
		esac
	done

	for fn in `ls -R -r -1 "$GTD_ROOT" | grep ".id="`; do
		fs_print_fi "$fn" "1n"
	done
}
#=== Edit =====================================================================
usage_edit() {
	cat<<-EOF
Usage: gtd edit [OPTION]... <id or alias>
Edit a file with a specified editor.
The file is specified by its id or alias.
The editor can be specified with the following method (sorted by priority):
  1. Use option -e or --editor
  2. Use GTD_EDITOR variable
  3. Use editor variable in the .gtdrc file beside the gtd command script. 
  4. If none of the above provided, use vim or vi if your OS provided them.

Options:
  -e, --editor=EDITOR  Use the specified editor.
	EOF
}

#TODO: test the options choosing the editor
select_editor() { # need $editor in the caller and will manipulate
	if [ -z "$editor" ]; then
		if [ -z "$GTD_EDITOR" ]; then
			editor=`get_config editor`
			[ -n editor ] && \
			  vecho "Editor $editor specified from .gtdrc."
		else
			editor="$GTD_EDITOR"
			vecho "Editor $editor specified from GTD_EDITOR."
		fi
	fi
	if [ -z "$editor" ]; then
		if [ -n `command -v vim` ]; then
			editor=vim
		elif [ -n `command -v vi` ]; then
			editor=vi
		else
			echo "No editor specified, and no vim or vi."
			echo "Please specify an editor that can be used."
			usage_edit
			return
		fi
		echo "No editor specified, using $editor."
	else # editor specified, check it's existence
		if [ -z `command -v $editor` ]; then # not exist
			echo "Editor $editor not exist, please try another."
			return
		fi
	fi
}

gtd_edit() {
	PARAMS=`getopt -o e: --long editor: \
	  -n 'gtd.edit' -- "$@"`
	[ $? != 0 ] && echo "Failed parsing the arguments." && return
	eval set -- "$PARAMS"
	debug "gtd_edit($@)"
	local editor=""
	while : ; do
		case "$1" in
		-e|--editor) editor="$2"
			vecho "Editor $editor specified from command line."
			shift 2;;
		--) shift; break;;
		*) echo "Unknown option: $1"; return;;
		esac
	done

	select_editor
	[ -z "$editor" ] && return

	if [ $# -eq 0 ]; then # no arg -- edit this script file
		fn="${BASH_SOURCE[0]}"
	else
		fn=`fs_id2fp $1`
		[ -z "$fn" ] && echo "ID $1 not found." && return
	fi
	echo "Edit $fn ..."
	$editor "$fn"
}

#=== TEST functions in place ===================================================
usage_test() {
	cat<<-EOF
Usage: gtd test [OPTION]...
Internal test of gtd functions.

Options:
  -o, --option=VALUE  Meaning
	EOF
}

gtd_test() {
	PARAMS=`getopt -o t: --long task: -n 'gtd.test' -- "$@"`
	[ $? != 0 ] && echo "Failed parsing the arguments." && return
	eval set -- "$PARAMS"
	debug "gtd_test($@)"
	local task=""
	while : ; do
		case "$1" in
		-t|--task) task="$2" shift 2;; #TODO:support multi task
		--) shift; break;;
		*) echo "Unknown option: $1"; return;;
		esac
	done

	fn=`fs_id2fn 1006`
	fs_parse_fn $fn
}
#=== SHELL =====================================================================
usage_shell() {  #heredoc
	cat<<-EOF
Shell-like environment, where you can run gtd commands without typing 'gtd'.
	EOF
}

in_shell=false
process_command() {
	[ $# -eq 0 ] && usage && return 0  #No arg, show usage

	case "$1" in  #$1 is command
	init) [ $help_me == true ] && usage_init || gtd_init;;
	ps1) gtd_ps1;;
	config) [ $help_me == true ] && usage_config || vim "$GTD_ROOT/.gtdrc";;
	md|mkdir) shift; [ $help_me == true ] && usage_mkdir || gtd_mkdir "$@";;
	a|add) shift; [ $help_me == true ] && usage_add || gtd_add "$@";;
	m|mv|move) shift; [ $help_me == true ] && usage_move || gtd_move "$@";;
	l|ls|list) shift; [ $help_me == true ] && usage_list || gtd_list "$@";;
	e|ed|edit) shift; [ $help_me == true ] && usage_edit || gtd_edit "$@";;
	shell) [ $in_shell == false ] && gtd_shell "$@"\
	  || echo "We are already in gtd shell.";;
  	exit) [ $in_shell == true ] && in_shell=false \
	  || echo "exit is a gtd shell command.";;
  	help) usage;;
	version) echo "0.02 2017-08-24 paulo.dx@gmail.com";;
	test) shift; [ $help_me == true ] && usage_test || gtd_test "$@";;
	*) echo "Incorrect command: $1"; usage;;
	esac
	return 0
}

gtd_shell() {
	[ $help_me == true ] && usage_shell && return

	in_shell=true
	while : ; do # infinite loop
		printf "gtd~ "
		read args
		eval set -- "$args"
		process_command "$@"
		[ $in_shell == false ] && break
	done
}
#=== MAIN ======================================================================
[ $# -eq 0 ] && usage && exit # bkm for no arg check

# process help & verbose & debug in 1 place
args=() # empty array
help_me=false; verbose=false; debug=false
for arg in "$@"; do
	case "$arg" in
	'-?'|-h|--help) help_me=true;; # ? is a wildcard if not br by ''
	-v|--verbose) verbose=true;;
	--debug) debug=true;;
	*) args+=("$arg");; # collect args other than help/verbose/debug
	esac
done

if [[ $help_me == false && "$1" != init ]]; then
  # help_me will always be processed (because showing help need nearly nothing)
  # init will always be processed
  # other commands need at least a working dir, and should run in child shell
	if [[ "$0" == *"bash" ]]; then # source mode: `. gtd` or `source gtd`
		echo "gtd command should not run in source mode."
		return # exit in source mode will exit the shell
	fi # common (non-source) mode below
	if [ -z "$GTD_ROOT" ]; then
		echo "No working directory specified."
		echo "Please run '. $0 init' first."
		usage_init
		exit 0
	fi
fi

[ -z $(command -v getopt) ] && echo "No getopt command." && exit 1
#TODO: give the user some hint to find the package containing the getopt cmd
process_command "${args[@]}"
#=== Template ==================================================================
usage_template() {
	cat<<-EOF
Usage: gtd template [OPTION]...
   or: gtd template [OPTION]...
Description

Options:
  -o, --option=VALUE  Meaning
	EOF
}

gtd_template() {
	PARAMS=`getopt -o ab: --long apple,banana: \
	  -n 'gtd.template' -- "$@"`
	[ $? != 0 ] && echo "Failed parsing the arguments." && return
	eval set -- "$PARAMS"
	debug "gtd_template($@)"
	local apple=false; local banana=""
	while : ; do
		case "$1" in
		-a|--apple) apple=true; shift;;
		-b|--banana) banana="$2"; shift 2;;
		--) shift; break;;
		*) echo "Unknown option: $1"; return;;
		esac
	done
}
